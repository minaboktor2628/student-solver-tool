// docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Role {
  PLA
  GLA
  TA
  COORDINATOR
  PROFESSOR
}

enum PreferenceLevel {
  PREFER
  STRONGLY_PREFER
}

enum Day {
  M
  T
  W
  R
  F
}

enum TermLetter {
  A
  B
  C
  D
}

enum AcademicLevel {
  UNDERGRADUATE
  GRADUATE
}

model Term {
  id         String     @id @default(cuid())
  termLetter TermLetter // Fall semester gets combined with A term, Spring with C term
  year       Int

  staffPreferences StaffPreference[]
  sections         Section[]
  allowedUsers     User[] // This term's participating PLAs/TAs/Professors

  termStaffDueDate     DateTime // When PLAs/TAs should have their preferences submitted by
  termProfessorDueDate DateTime // When professors should have their preferences submitted by
  createdAt            DateTime @default(now())
  active               Boolean  @default(false)

  @@unique([termLetter, year])
}

model StaffPreference {
  id String @id @default(cuid())

  // Associated staff
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  // Associated term
  term   Term   @relation(fields: [termId], references: [id], onDelete: Cascade)
  termId String

  isAvailableForTerm Boolean @default(false) // Whether the staff is available to work this term at all

  timesAvailable StaffAvailableHour[]
  canEdit        Boolean              @default(true) // Has ability to still modify their preferences or not
  comments       String? // Any additional comments that the staff has

  qualifiedForSections StaffPreferenceQualifiedSection[]
  preferredSections    StaffPreferencePreferredSection[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // one staff preference per user per term
  @@unique([userId, termId])
}

// Courses the staff can be assigned to
model StaffPreferenceQualifiedSection {
  staffPreference   StaffPreference @relation(fields: [staffPreferenceId], references: [id], onDelete: Cascade)
  staffPreferenceId String

  section   Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  sectionId String

  @@id([staffPreferenceId, sectionId])
}

// Ordered list of preferred sections
model StaffPreferencePreferredSection {
  rank PreferenceLevel

  staffPreference   StaffPreference @relation(fields: [staffPreferenceId], references: [id], onDelete: Cascade)
  staffPreferenceId String

  section   Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  sectionId String

  @@id([staffPreferenceId, sectionId])
}

// Which staff (users) are actually assigned to a section
model SectionAssignment {
  id String @id @default(cuid())

  section   Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  sectionId String

  staff   User   @relation(fields: [staffId], references: [id], onDelete: Cascade)
  staffId String

  locked Boolean @default(false) // if true, solver must not change/remove this

  // Prevent duplicate assignments
  @@unique([sectionId, staffId])
}

model Section {
  id String @id @default(cuid())

  term   Term   @relation(fields: [termId], references: [id], onDelete: Cascade)
  termId String

  courseTitle    String // Ex: "Discrete Mathematics"
  courseCode     String // Ex: "CS 2022"
  courseSection  String // Ex: "LO1"
  meetingPattern String // Ex: "M-R | 2:00pm - 3:50pm"
  description    String // Course description (stored as an html string)

  professor   User?   @relation("TeachesSections", fields: [professorId], references: [id])
  professorId String?

  enrollment    Int // Number of students enrolled in this course
  capacity      Int // Max number of students allowed to enroll in this course
  requiredHours Int // Number of staff hours required to fulfill this course's needs
  academicLevel AcademicLevel // Undergraduate or Graduate

  assignments          SectionAssignment[]
  qualifiedPreferences StaffPreferenceQualifiedSection[]
  preferredPreferences StaffPreferencePreferredSection[]
  professorPreference  ProfessorPreference?
}

model ProfessorPreference {
  id String @id @default(cuid())

  section   Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  sectionId String  @unique

  canEdit       Boolean             @default(true) // Has ability to still modify their preferences or not
  timesRequired SectionNeededHour[]
  comments      String?

  preferredStaff ProfessorPreferencePreferredStaff[]
  avoidedStaff   ProfessorPreferenceAvoidedStaff[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Which staff the professor prefers for this course
model ProfessorPreferencePreferredStaff {
  professorPreference   ProfessorPreference @relation(fields: [professorPreferenceId], references: [id], onDelete: Cascade)
  professorPreferenceId String

  staff   User   @relation("ProfPrefPreferredStaff", fields: [staffId], references: [id], onDelete: Cascade)
  staffId String

  @@id([professorPreferenceId, staffId])
}

// Which staff the professor does NOT want for this course
model ProfessorPreferenceAvoidedStaff {
  professorPreference   ProfessorPreference @relation(fields: [professorPreferenceId], references: [id], onDelete: Cascade)
  professorPreferenceId String

  staff   User   @relation("ProfPrefAvoidedStaff", fields: [staffId], references: [id], onDelete: Cascade)
  staffId String

  @@id([professorPreferenceId, staffId])
}

model StaffAvailableHour {
  id                String           @id @default(uuid())
  hour              Int
  day               Day
  StaffPreference   StaffPreference? @relation(fields: [staffPreferenceId], references: [id])
  staffPreferenceId String?
}

model SectionNeededHour {
  id                    String               @id @default(uuid())
  hour                  Int
  day                   Day
  ProfessorPreference   ProfessorPreference? @relation(fields: [professorPreferenceId], references: [id])
  professorPreferenceId String?
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String?    @unique
  emailVerified DateTime?
  accounts      Account[]
  sessions      Session[]
  roles         UserRole[]

  // staff specific
  hours              Int?
  staffPreferences   StaffPreference[]
  sectionAssignments SectionAssignment[]
  preferredInCourses ProfessorPreferencePreferredStaff[] @relation("ProfPrefPreferredStaff")
  avoidedInCourses   ProfessorPreferenceAvoidedStaff[]   @relation("ProfPrefAvoidedStaff")

  // professor specific
  teaches Section[] @relation("TeachesSections")

  AllowedInTerms Term[]
}

model UserRole {
  role   Role
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@id([userId, role])
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  refresh_token_expires_in Int?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
